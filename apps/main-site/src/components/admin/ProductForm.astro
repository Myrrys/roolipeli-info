---
import {
  type Creator,
  type Product,
  ProductLangEnum,
  ProductTypeEnum,
  type Publisher,
  type SemanticLabel,
} from '@roolipeli/database';
import { useTranslations } from '../../i18n/utils';
import FormField from './FormField.astro';

interface LabelEntry {
  label_id: string;
}

interface Props {
  product?: Product & {
    creators?: { creator_id: string; role: string }[];
    labels?: LabelEntry[];
    references?: { reference_type: string; label: string; url: string }[];
    isbns?: { isbn: string; label: string | null }[];
  };
  publishers: Publisher[];
  creators: Creator[];
  labels?: SemanticLabel[];
  submitUrl: string;
  method?: 'POST' | 'PUT';
}

const { product, publishers, creators, labels = [], submitUrl, method = 'POST' } = Astro.props;

const t_key = useTranslations((Astro.currentLocale as 'fi' | 'sv' | 'en') || 'fi');

// Pass Supabase config to client script via data attributes
const supabaseUrl = import.meta.env.SUPABASE_URL?.split('\n')[0].trim();
const supabaseAnonKey = import.meta.env.SUPABASE_ANON_KEY?.split('\n')[0].trim();

// Prepare initial state
const initialCreators = product?.creators || [];
const jsonInitialCreators = JSON.stringify(initialCreators);
const jsonAllCreators = JSON.stringify(creators);

const initialLabels = product?.labels || [];
const jsonInitialLabels = JSON.stringify(initialLabels);
const jsonAllLabels = JSON.stringify(labels);

const initialReferences = product?.references || [];
const jsonInitialReferences = JSON.stringify(initialReferences);

const initialIsbns = product?.isbns || [];
const jsonInitialIsbns = JSON.stringify(initialIsbns);
---

<form
    id="product-form"
    class="admin-form"
    data-method={method}
    data-url={submitUrl}
    data-initial-creators={jsonInitialCreators}
    data-all-creators={jsonAllCreators}
    data-initial-labels={jsonInitialLabels}
    data-all-labels={jsonAllLabels}
    data-initial-references={jsonInitialReferences}
    data-initial-isbns={jsonInitialIsbns}
    data-supabase-url={supabaseUrl}
    data-supabase-anon-key={supabaseAnonKey}
>
    <div class="form-grid">
        <FormField label="Title" name="title" value={product?.title} required />
        <FormField
            label="Slug"
            name="slug"
            type="slug"
            value={product?.slug}
            required
        />
    </div>

    <!-- Cover Image Section -->
    <div class="form-group">
        <label for="cover-upload">Cover Image</label>
        <input
            type="file"
            id="cover-upload"
            accept="image/jpeg,image/png,image/webp"
            data-existing-path={product?.cover_image_path || ""}
        />
        <div id="cover-error" class="field-error hidden"></div>
        <div id="cover-preview-container" class="hidden">
            <img id="cover-preview" alt="Cover preview" class="cover-preview-image" />
            <button type="button" id="remove-cover-btn" class="btn-danger-text">Remove Cover</button>
        </div>
    </div>

    <div class="form-grid">
        <div class="form-group">
            <label for="publisher_id">Publisher</label>
            <select id="publisher_id" name="publisher_id">
                <option value="">-- None --</option>
                {
                    publishers.map((p) => (
                        <option
                            value={p.id}
                            selected={product?.publisher_id === p.id}
                        >
                            {p.name}
                        </option>
                    ))
                }
            </select>
        </div>

        <div class="form-group">
            <label for="product_type">Type</label>
            <select id="product_type" name="product_type">
                {
                    ProductTypeEnum.options.map((t) => (
                        <option
                            value={t}
                            selected={product?.product_type === t}
                        >
                            {t_key(`productType.${t}` as any)}
                        </option>
                    ))
                }
            </select>
        </div>
    </div>

    <div class="form-grid">
        <FormField
            label="Year"
            name="year"
            type="number"
            value={product?.year ?? ""}
        />
    </div>

    <div class="form-group">
        <label for="lang">Language</label>
        <select id="lang" name="lang">
            {
                ProductLangEnum.options.map((l) => (
                    <option value={l} selected={product?.lang === l}>
                        {t_key(`lang.${l}` as any)}
                    </option>
                ))
            }
        </select>
    </div>

    <FormField
        label="Description"
        name="description"
        type="textarea"
        value={product?.description ?? ""}
    />

    <!-- ISBNs Section -->
    <div class="isbns-section">
        <h3>ISBNs</h3>
        <div id="isbns-list">
            <!-- Rows injected by JS -->
        </div>
        <button type="button" id="add-isbn-btn" class="btn-secondary"
            >+ Add ISBN</button
        >
    </div>

    <!-- Creators Section -->
    <div class="creators-section">
        <h3>Creators</h3>
        <div id="creators-list">
            <!-- Rows injected by JS -->
        </div>
        <button type="button" id="add-creator-btn" class="btn-secondary"
            >+ Add Creator</button
        >
    </div>

    <!-- Labels Section -->
    <div class="labels-section">
        <h3>Semantic Labels</h3>
        <div id="labels-list">
            <!-- Rows injected by JS -->
        </div>
        <button type="button" id="add-label-btn" class="btn-secondary"
            >+ Add Label</button
        >
    </div>

    <!-- References Section -->
    <div class="references-section">
        <h3>References</h3>
        <div id="references-list">
            <!-- Rows injected by JS -->
        </div>
        <button type="button" id="add-reference-btn" class="btn-secondary"
            >+ Add Reference</button
        >
    </div>

    <div class="form-actions">
        <a href="/admin/products" class="btn-cancel">Cancel</a>
        <button type="submit" class="btn-save">Save Product</button>
    </div>
</form>

<script>
    import { createBrowserClient } from "@supabase/ssr";
    import { setupAutoSlug } from "../../lib/slug.client";
    import type { Creator, SemanticLabel } from "@roolipeli/database";

    interface CreatorEntry {
        creator_id: string;
        role: string;
    }

    interface LabelEntry {
        label_id: string;
    }

    interface ReferenceEntry {
        reference_type: string;
        label: string;
        url: string;
    }

    const form = document.getElementById("product-form") as HTMLFormElement;
    const creatorsContainer = document.getElementById("creators-list");
    const addCreatorBtn = document.getElementById("add-creator-btn");
    const labelsContainer = document.getElementById("labels-list");
    const addLabelBtn = document.getElementById("add-label-btn");
    const referencesContainer = document.getElementById("references-list");
    const addReferenceBtn = document.getElementById("add-reference-btn");
    const isbnsContainer = document.getElementById("isbns-list");
    const addIsbnBtn = document.getElementById("add-isbn-btn");

    if (!form || !creatorsContainer || !addCreatorBtn) {
        console.error("ProductForm elements not found");
    }

    // Parse data from attributes
    let assignedCreators: CreatorEntry[] = [];
    let allCreators: Creator[] = [];
    let assignedLabels: LabelEntry[] = [];
    let allLabels: SemanticLabel[] = [];
    let assignedReferences: ReferenceEntry[] = [];
    let assignedIsbns: { isbn: string; label: string }[] = [];

    try {
        if (form?.dataset.initialCreators) {
            assignedCreators = JSON.parse(form.dataset.initialCreators);
        }
        if (form?.dataset.allCreators) {
            allCreators = JSON.parse(form.dataset.allCreators);
        }
        if (form?.dataset.initialLabels) {
            assignedLabels = JSON.parse(form.dataset.initialLabels);
        }
        if (form?.dataset.allLabels) {
            allLabels = JSON.parse(form.dataset.allLabels);
        }
        if (form?.dataset.initialReferences) {
            assignedReferences = JSON.parse(form.dataset.initialReferences);
        }
        if (form?.dataset.initialIsbns) {
            assignedIsbns = JSON.parse(form.dataset.initialIsbns);
        }
    } catch (e) {
        console.error("Failed to parse data", e);
    }

    // === COVER IMAGE UPLOAD ===
    const sbUrl = form?.dataset.supabaseUrl ?? "";
    const sbKey = form?.dataset.supabaseAnonKey ?? "";
    const supabase = createBrowserClient(sbUrl, sbKey);

    const coverInput = document.getElementById("cover-upload") as HTMLInputElement;
    const coverError = document.getElementById("cover-error") as HTMLElement;
    const coverPreviewContainer = document.getElementById("cover-preview-container") as HTMLElement;
    const coverPreview = document.getElementById("cover-preview") as HTMLImageElement;
    const removeCoverBtn = document.getElementById("remove-cover-btn") as HTMLButtonElement;

    let selectedFile: File | null = null;
    let shouldRemoveCover = false;
    let existingCoverPath: string | null = coverInput?.dataset.existingPath || null;

    // Show existing cover if present
    if (existingCoverPath && coverInput) {
        const { data } = supabase.storage.from("covers").getPublicUrl(existingCoverPath);
        if (data?.publicUrl) {
            coverPreview.src = data.publicUrl;
            coverPreviewContainer.classList.remove("hidden");
        }
    }

    function showCoverError(message: string) {
        if (coverError) {
            coverError.textContent = message;
            coverError.classList.remove("hidden");
        }
    }

    function hideCoverError() {
        if (coverError) {
            coverError.classList.add("hidden");
        }
    }

    // File selection handler
    if (coverInput) {
        coverInput.addEventListener("change", (e) => {
            const target = e.target as HTMLInputElement;
            const file = target.files?.[0];

            if (!file) return;

            hideCoverError();

            // Validate size (5MB = 5242880 bytes)
            if (file.size > 5242880) {
                showCoverError("File size must be less than 5MB");
                coverInput.value = "";
                return;
            }

            // Validate MIME type
            const validTypes = ["image/jpeg", "image/png", "image/webp"];
            if (!validTypes.includes(file.type)) {
                showCoverError("File must be JPEG, PNG, or WebP");
                coverInput.value = "";
                return;
            }

            // Show preview
            selectedFile = file;
            shouldRemoveCover = false;
            const reader = new FileReader();
            reader.onload = (e) => {
                if (e.target?.result) {
                    coverPreview.src = e.target.result as string;
                    coverPreviewContainer.classList.remove("hidden");
                }
            };
            reader.readAsDataURL(file);
        });
    }

    // Remove cover button
    if (removeCoverBtn) {
        removeCoverBtn.addEventListener("click", () => {
            selectedFile = null;
            shouldRemoveCover = true;
            if (coverInput) coverInput.value = "";
            coverPreviewContainer.classList.add("hidden");
            hideCoverError();
        });
    }

    function renderCreators() {
        if (!creatorsContainer) return;
        creatorsContainer.innerHTML = "";
        assignedCreators.forEach((entry, index) => {
            const row = document.createElement("div");
            row.className = "creator-row";

            // Creator Select
            const select = document.createElement("select");
            select.className = "creator-select";
            select.value = entry.creator_id;
            select.innerHTML = `<option value="">Select Creator...</option>`;

            allCreators.forEach((c) => {
                const opt = document.createElement("option");
                opt.value = c.id ?? "";
                opt.textContent = c.name;
                if (c.id === entry.creator_id) opt.selected = true;
                select.appendChild(opt);
            });

            select.onchange = (e) => {
                assignedCreators[index].creator_id = (
                    e.target as HTMLFormElement
                ).value;
            };

            // Role Input
            const roleInput = document.createElement("input");
            roleInput.type = "text";
            roleInput.placeholder = "Role (e.g. Author)";
            roleInput.value = entry.role;
            roleInput.className = "creator-role";
            roleInput.oninput = (e) => {
                assignedCreators[index].role = (
                    e.target as HTMLFormElement
                ).value;
            };

            // Remove Button
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.textContent = "×";
            removeBtn.className = "btn-icon-remove";
            removeBtn.onclick = () => {
                assignedCreators.splice(index, 1);
                renderCreators();
            };

            row.appendChild(select);
            row.appendChild(roleInput);
            row.appendChild(removeBtn);
            creatorsContainer.appendChild(row);
        });
    }

    function renderLabels() {
        if (!labelsContainer) return;
        labelsContainer.innerHTML = "";
        assignedLabels.forEach((entry, index) => {
            const row = document.createElement("div");
            row.className = "label-row";

            // Label Select
            const select = document.createElement("select");
            select.className = "label-select";
            select.innerHTML = `<option value="">Select Label...</option>`;

            allLabels.forEach((l) => {
                const opt = document.createElement("option");
                opt.value = l.id ?? "";
                opt.textContent = `${l.label}${l.wikidata_id ? ` (${l.wikidata_id})` : ""}`;
                if (l.id === entry.label_id) opt.selected = true;
                select.appendChild(opt);
            });

            select.onchange = (e) => {
                assignedLabels[index].label_id = (
                    e.target as HTMLFormElement
                ).value;
            };

            // Remove Button
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.textContent = "×";
            removeBtn.className = "btn-icon-remove";
            removeBtn.onclick = () => {
                assignedLabels.splice(index, 1);
                renderLabels();
            };

            row.appendChild(select);
            row.appendChild(removeBtn);
            labelsContainer.appendChild(row);
        });
    }

    function renderReferences() {
        if (!referencesContainer) return;
        referencesContainer.innerHTML = "";
        assignedReferences.forEach((entry, index) => {
            const row = document.createElement("div");
            row.className = "reference-row";

            // Type Select
            const select = document.createElement("select");
            select.className = "reference-type-select";
            const types = ["official", "source", "review", "social"];
            select.innerHTML = types
                .map(
                    (t) =>
                        `<option value="${t}" ${entry.reference_type === t ? "selected" : ""}>${t.charAt(0).toUpperCase() + t.slice(1)}</option>`,
                )
                .join("");
            select.onchange = (e) => {
                assignedReferences[index].reference_type = (
                    e.target as HTMLFormElement
                ).value;
            };

            // Label Input
            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.placeholder = "Label (e.g. Website)";
            labelInput.value = entry.label;
            labelInput.className = "reference-label";
            labelInput.oninput = (e) => {
                assignedReferences[index].label = (
                    e.target as HTMLFormElement
                ).value;
            };

            // URL Input
            const urlInput = document.createElement("input");
            urlInput.type = "url";
            urlInput.placeholder = "URL";
            urlInput.value = entry.url;
            urlInput.className = "reference-url";
            urlInput.oninput = (e) => {
                assignedReferences[index].url = (
                    e.target as HTMLFormElement
                ).value;
            };

            // Remove Button
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.textContent = "×";
            removeBtn.className = "btn-icon-remove";
            removeBtn.onclick = () => {
                assignedReferences.splice(index, 1);
                renderReferences();
            };

            row.appendChild(select);
            row.appendChild(labelInput);
            row.appendChild(urlInput);
            row.appendChild(removeBtn);
            referencesContainer.appendChild(row);
        });
    }

    function renderIsbns() {
        if (!isbnsContainer) return;
        isbnsContainer.innerHTML = "";
        assignedIsbns.forEach((entry, index) => {
            const row = document.createElement("div");
            row.className = "isbn-row";

            // ISBN Input
            const isbnInput = document.createElement("input");
            isbnInput.type = "text";
            isbnInput.placeholder = "ISBN (e.g. 978-...)";
            isbnInput.value = entry.isbn;
            isbnInput.className = "isbn-input";
            isbnInput.oninput = (e) => {
                assignedIsbns[index].isbn = (e.target as HTMLFormElement).value;
            };

            // Label Input
            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.placeholder = "Label (e.g. PDF)";
            labelInput.value = entry.label || "";
            labelInput.className = "isbn-label";
            labelInput.oninput = (e) => {
                assignedIsbns[index].label = (
                    e.target as HTMLFormElement
                ).value;
            };

            // Remove Button
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.textContent = "×";
            removeBtn.className = "btn-icon-remove";
            removeBtn.onclick = () => {
                assignedIsbns.splice(index, 1);
                renderIsbns();
            };

            row.appendChild(isbnInput);
            row.appendChild(labelInput);
            row.appendChild(removeBtn);
            isbnsContainer.appendChild(row);
        });
    }

    if (addCreatorBtn) {
        addCreatorBtn.addEventListener("click", () => {
            assignedCreators.push({ creator_id: "", role: "" });
            renderCreators();
        });
    }

    if (addLabelBtn) {
        addLabelBtn.addEventListener("click", () => {
            assignedLabels.push({ label_id: "" });
            renderLabels();
        });
    }

    if (addReferenceBtn) {
        addReferenceBtn.addEventListener("click", () => {
            assignedReferences.push({
                reference_type: "official",
                label: "",
                url: "",
            });
            renderReferences();
        });
    }

    if (addIsbnBtn) {
        addIsbnBtn.addEventListener("click", () => {
            assignedIsbns.push({ isbn: "", label: "" });
            renderIsbns();
        });
    }

    // Initial Render
    renderCreators();
    renderLabels();
    renderReferences();
    renderIsbns();

    // Auto Slug
    setupAutoSlug('input[name="title"]', 'input[name="slug"]');

    if (form) {
        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            hideCoverError();

            const url = form.dataset.url;
            const method = form.dataset.method || "POST";
            if (!url) return;

            // Extract product_id from URL for cover upload path
            const productIdMatch = url.match(/\/products\/([^\/]+)$/);
            const productId = productIdMatch?.[1];

            try {
                let coverImagePath: string | null = existingCoverPath;

                // Handle cover upload/removal
                if (productId) {
                    // Remove cover if requested
                    if (shouldRemoveCover && existingCoverPath) {
                        const { error: deleteError } = await supabase.storage
                            .from("covers")
                            .remove([existingCoverPath]);
                        if (deleteError) {
                            showCoverError("Failed to remove cover: " + deleteError.message);
                            return;
                        }
                        coverImagePath = null;
                    }

                    // Upload new cover
                    if (selectedFile) {
                        // Delete old cover if replacing
                        if (existingCoverPath) {
                            await supabase.storage.from("covers").remove([existingCoverPath]);
                        }

                        // Get file extension
                        const ext = selectedFile.name.split('.').pop()?.toLowerCase() || 'jpg';
                        const uploadPath = `${productId}/cover.${ext}`;

                        const { error: uploadError } = await supabase.storage
                            .from("covers")
                            .upload(uploadPath, selectedFile, { upsert: true });

                        if (uploadError) {
                            showCoverError("Upload failed: " + uploadError.message);
                            return;
                        }

                        coverImagePath = uploadPath;
                    }
                }

                // Gather standard fields
                const formData = new FormData(form);
                const rawData = Object.fromEntries(formData.entries());

                // Process types
                const yearValue = rawData.year as string;
                const pubValue = rawData.publisher_id as string;
                const data = {
                    ...rawData,
                    year: yearValue ? parseInt(yearValue) : null,
                    publisher_id: pubValue === "" ? null : pubValue,
                    cover_image_path: coverImagePath,
                };

                // Filter out empty entries
                const validCreators = assignedCreators.filter(
                    (c) => c.creator_id && c.role,
                );
                const validLabels = assignedLabels.filter((l) => l.label_id);
                const validReferences = assignedReferences.filter(
                    (r) => r.label && r.url,
                );
                const validIsbns = assignedIsbns.filter((i) => i.isbn);

                const payload = {
                    ...data,
                    creators: validCreators,
                    labels: validLabels,
                    references: validReferences,
                    isbns: validIsbns,
                };

                const res = await fetch(url, {
                    method: method,
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });

                if (res.ok) {
                    window.location.href = "/admin/products?success=saved";
                } else {
                    const result = await res.json();
                    alert("Error: " + (result.error || "Unknown error"));
                }
            } catch (err) {
                console.error(err);
                showCoverError("Network error: " + (err as Error).message);
            }
        });
    }

    // Signal that all event listeners are attached
    form?.setAttribute("data-initialized", "true");
</script>

<style>
    .form-group {
        display: flex;
        flex-direction: column;
        gap: var(--kide-space-2);
        margin-bottom: var(--kide-space-4);
    }

    label {
        font-weight: 600;
        color: var(--kide-ink-header);
        font-size: 0.9rem;
    }

    select {
        padding: var(--kide-space-3);
        border: 1px solid var(--kide-border-strong);
        border-radius: var(--kide-radius-sm);
        font-family: inherit;
        font-size: 1rem;
        background: var(--kide-surface);
    }

    /* Creators Section */
    .creators-section {
        margin: var(--kide-space-6) 0;
        padding: var(--kide-space-4);
        border: 1px solid var(--kide-border-weak);
        border-radius: var(--kide-radius-md);
        background: var(--kide-subtle);
    }

    h3 {
        margin-top: 0;
        margin-bottom: var(--kide-space-4);
        font-size: 1.1rem;
        font-weight: 600;
    }

    .creator-row {
        display: flex;
        gap: var(--kide-space-2);
        margin-bottom: var(--kide-space-2);
    }

    .creator-select {
        flex: 2;
    }

    .creator-role {
        flex: 1;
        padding: var(--kide-space-3);
        border: 1px solid var(--kide-border-strong);
        border-radius: var(--kide-radius-sm);
    }

    .btn-secondary {
        background: transparent;
        border: 1px dashed var(--kide-border-active);
        color: var(--kide-ink-active);
        padding: var(--kide-space-2) var(--kide-space-4);
        cursor: pointer;
        border-radius: var(--kide-radius-sm);
    }

    .btn-secondary:hover {
        background: var(--kide-glass-white);
        border-color: var(--kide-brand-primary);
        color: var(--kide-brand-primary);
    }

    .btn-icon-remove {
        background: var(--kide-danger-bg);
        color: var(--kide-danger);
        border: none;
        width: 40px;
        cursor: pointer;
        border-radius: var(--kide-radius-sm);
        font-size: 1.25rem;
        line-height: 1;
    }

    .btn-icon-remove:hover {
        background: var(--kide-danger);
        color: var(--kide-surface);
    }

    /* Labels Section */
    .labels-section {
        margin: var(--kide-space-6) 0;
        padding: var(--kide-space-4);
        border: 1px solid var(--kide-border-weak);
        border-radius: var(--kide-radius-md);
        background: var(--kide-subtle);
    }

    .label-row {
        display: flex;
        gap: var(--kide-space-2);
        margin-bottom: var(--kide-space-2);
    }

    .label-select {
        flex: 1;
    }

    /* References Section */
    .references-section {
        margin: var(--kide-space-6) 0;
        padding: var(--kide-space-4);
        border: 1px solid var(--kide-border-weak);
        border-radius: var(--kide-radius-md);
        background: var(--kide-subtle);
    }

    .reference-row {
        display: flex;
        gap: var(--kide-space-2);
        margin-bottom: var(--kide-space-2);
    }

    .reference-type-select {
        flex: 1;
    }

    .reference-label {
        flex: 2;
        padding: var(--kide-space-3);
        border: 1px solid var(--kide-border-strong);
        border-radius: var(--kide-radius-sm);
    }

    .reference-url {
        flex: 3;
        padding: var(--kide-space-3);
        border: 1px solid var(--kide-border-strong);
        border-radius: var(--kide-radius-sm);
    }

    /* ISBNs Section */
    .isbns-section {
        margin: var(--kide-space-6) 0;
        padding: var(--kide-space-4);
        border: 1px solid var(--kide-border-subtle);
        border-radius: var(--kide-radius-md);
        background: var(--kide-paper);
    }

    .isbn-row {
        display: flex;
        gap: var(--kide-space-2);
        margin-bottom: var(--kide-space-2);
    }

    .isbn-input {
        flex: 2;
        padding: var(--kide-space-3);
        border: 1px solid var(--kide-border-strong);
        border-radius: var(--kide-radius-sm);
    }

    .isbn-label {
        flex: 1;
        padding: var(--kide-space-3);
        border: 1px solid var(--kide-border-strong);
        border-radius: var(--kide-radius-sm);
    }

    /* Cover Image Upload */
    .field-error {
        color: var(--kide-danger);
        font-size: var(--kide-font-size-sm);
        margin-top: var(--kide-space-1);
        padding: var(--kide-space-2);
        background: var(--kide-danger-bg);
        border-radius: var(--kide-radius-sm);
        border: 1px solid var(--kide-danger);
    }

    .btn-danger-text {
        background: transparent;
        border: none;
        color: var(--kide-danger);
        cursor: pointer;
        padding: var(--kide-space-2);
        font-size: var(--kide-font-size-sm);
        text-decoration: underline;
        margin-top: var(--kide-space-2);
    }

    .btn-danger-text:hover {
        color: var(--kide-danger-hover);
    }

    .hidden {
        display: none;
    }

    .cover-preview-image {
        max-width: 300px;
        border-radius: var(--kide-radius-md);
    }
</style>
